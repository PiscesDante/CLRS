## 第2章 算法基础

### 2.1 插入排序

我们的第一个算法（插入排序）求解第一章中引入的排序问题：

**输入**：n个数的一个序列<a1, a2, ... , an>。

**输出**：输入序列的一个排序<a1', a2', ... , an'>，满足a1' <= a2' <= ... <= an'。

我们希望排序的数也称为关键词。

```伪代码
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] > key
        A[i + 1] = A[i]
        i = i - 1;
    A[i + 1] = key
```

我们使用C++实现这个算法：

```C++
for (int i = 1; i < A.size(); ++i) {
    int curr = A[i];
    int j = i - 1;
    while (j >= 0 && A[j] > curr) {
        A[j + 1] = A[j];
        --j;
    }
    A[j + 1] = curr;
}
```

#### 练习

**2.1-1** 以图2-2为模型，说明INSERTION-SORT在数组 A = <31,41,59,26,41,58> 上的执行过程。

**2.1-2** 重写INSERTION-SORT，使之按降序排序。

```C++
for (int i = 1; i < A.size(); ++i) {
    int curr = A[i];
    int j = i - 1;
    for (; j >= 0 && A[j] < curr; --j) {
        A[j + 1] = A[j];
    }
    A[j + 1] = curr;
}
```

**2.1-3** 考虑以下**查找问题**：**输入**：n个数的一个序列A = <a1, a2, ... , an>和一个值v。**输出**：下标i使得`v = A[i]`或者当v不在A中出现，v为特殊值NIL。写出线性查找的伪代码，它扫描整个序列来查找v使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。

```C++
for (int i = 0; i < A.size(); ++i) { if (A[i] == v) return i; }
return NIL;
```

**2.1-4** 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应该按二进制形式存储在一个`(n + 1)`元数组C中，请给出该问题的形式化描述，并写出伪代码。

```C++
int carry = 0;
for (int i = n - 1; i >= 0; --i) {
	C[i + 1] = A[i] + B[i] + carry;
    if (C[i + 1] > 1) {
        carry = 1;
        C[i + 1] %= 2;
    } else {
        carry = 0;
    }
}
C[0] = carry ? 1 : 0;
```

### 2.2 算法分析

一般来说通过分析求解某个问题的几种候选算法，我们可以选出一种最有效的算法。

##### 插入排序算法分析

该算法的最佳运行情况为：`an+b`。

该算法的最坏情况的运行时间为：`an^2 + bn +c`。

##### 最坏情况与平均情况分析

在分析插入排序时，我们既研究了最佳情况，其中输入数组已经排好序。又研究了最坏情况，其中输入数组反向排好序。然而，在本书的余下部分中，我们往往集中于只求**最坏情况运行时间**。基于以下三个原因：

* 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。
* 对于某些算法，最坏情况经常出现。
* “平均情况”往往和最坏情况大致一样差。

随机化算法允许进行概率分析并产生某个期望的运行时间。

##### 增长量级

我们真正感兴趣的是运行时间的**增长率**或者**增长量级**。如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，那么我们认为前者比后者更有效。

#### 练习

**2.2-1** 用记号O表示函数`n^3/1000 - 100n^2 - 100n + 3`。

```
n^3/1000 - 100n^2 - 100n + 3 == O(n^3)
```

**2.2-2** 考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素与A[2]交换。该算法称为**选择算法**。写出伪代码。该算法维持的循环不变式是什么？为什么它只需要对前`n - 1`个元素，而不是对所有n个元素进行排序？给出最好情况与最坏情况的运行时间。

```C++
for (int i = 0; i < A.size(); ++i) {
    int min_value = A[i];
    int min_index = i;
    for (int j = i + 1; j < A.size(); ++j) {
        if (A[j] < min_value) {
            min_value = A[j];
            min_index = j;
        }
    }
    std::swap(A[i], A[j]);
}
// 因为当n - 1个元素就位的时候剩下的那一个也必然就位
// 最好情况：O(n)
// 最坏情况：O(N^2)
```

**2.2-3** 再次考虑线性查找问题。假定要查找的元素等可能的为数组中的任何元素，平均需要检查输入序列的多少元素？最坏情况又如何？使用时间复杂度记号给出线性查找的平均情况和最坏情况。证明你的答案。

```
线性查找的平均时间复杂度需要O(n/2)
最坏需要O(n)
```

**2.2-4** 我们可以如何修改几乎任意算法来使之具有良好的最好情况运行时间。

### 2.3 设计算法

本节我们主要考察一种称为“分治法”的设计方法，我们将利用分治法来设计一个排序算法。

#### 2.3.1 分治法

许多有用的算法在结构上是**递归的**：为了解决一个给定的问题，算法依次或多次递归的调用其自身以解决紧密相关若干子问题。这些算法典型的遵循**分治法**的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归的求解这些子问题，然后再合并这些子问题的解来建立原问题的解。