## 第8章 线性时间排序

归并排序和堆排序的最坏情况时间复杂度是nlogn。快速排序的期望时间复杂度是nlogn。

以上算法有一个共同的性质：**在排序的结果中，各元素的次序依赖于它们之间的比较**。我们将这类排序算法称为**比较排序**。

接下来我们要讨论三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序。当然这些排序算法是使用运算而非比较来确定排序顺序的。

### 8.1 排序算法的下界

本节中我们假设所有输入的元素都是互异的。

##### 决策树模型

比较排序可以被抽象成为一棵决策树。决策树是一棵完全二叉树，它可以表示给定输入规模的情况下，某一特定排序算法对所有元素的比较操作。

##### 最坏情况的下界

在最坏情况下，任何比较排序算法都需要做Ω(nlgn)次比较。

堆排序和归并排序都是渐进最优的比较排序算法。

### 8.2 计数排序

计数排序假设n个输入元素的每一个都是在0到k区间内的一个整数，其中k为某个整数。

计数排序的基本思想是：**对每一个输入元素x，确定小于x的元素个数。利用这一信息，就可以直接把x放到它在输出数组中的位置上了**。

这里实现的思想是：给定一个数组，先统计各个元素出现的次数，用元素的值做下标，得到一个新的数组。然后扫描这个数组，对于数组的每个下标，如果对应的值不为零，说明原来的数组中有这样的值。由于下标是天然递增的，依次将这些值选中就可以得到排序后的数组。

但是这个方法有明显的局限性。

### 8.3 基数排序

基数排序是一种用在卡片排序机上的算法。

现在来做一个练习来阐述基数排序的核心思想：

```
练习8.2-1 说明基数排序在数组{73, 22, 93, 43, 55, 14, 28, 65, 39, 81}上的操作过程
先根据个位数进行排序
0
1 81
2 22
3 73 93 43
4 14
5 55 65
6
7
8 28
9 39

接下来我们将这个桶子里面的数值重新拼接成一个数组
81 22 73 93 43 14 55 65 28 39

接着再进行一次分配，这次我们按照十位数进行分配：
0
1 14
2 22 28
3 39
4 43
5 55
6 65
7 73
8 81
9 93

这时候我们再将这些数字串联起来得到：
14 22 28 39 43 55 65 73 81 93
```

这个时候我们看到这个数列已经排序完毕了，如果排序的对象有三位数以上，则持续以上的动作直到最高位为止。

### 8.4 桶排序

桶排序假设输入的数据服从均匀分布，平均情况下它的时间代价为O(n)。

桶排序和基数排序的原理大致相同。就是将待排序的数组元素放进天然有序的容器之中，从而达到排序的目的。



